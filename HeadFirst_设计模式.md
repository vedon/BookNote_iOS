#Head First

#设计原则

###封装变化


###多用组合，少用继承
```使用组合建立的系统具有很大的弹性，并且可以在运行时改变行为。只要组合对象符合正确接口标准就可以。```

###针对接口编程，不针对实现
```针对接口编程，关键在于多态。多态是什么不用说了，在iOS上，一般通过protocol 来实现这一原则。```

###为交互对象之间的松耦合合理设计
```观察者模式就是一种典型的松耦合设计。例如：iOS 中的通知。```

###开闭原则
对扩展开放，对修改关闭。典型的运用就是使用装饰模式。在一开始设计的时候，需要把注意力集中在设计中最有可能改变的地方，然后应用开闭原则。**不是所有地方都需要使用开闭原则的**

###依赖抽象，不要依赖具体类。







#设计模式
##装饰模式
动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的方案。

> * 装饰者继承被装饰者，是为了获得正确的类型，而不是继承它的行为。行为来自装饰者和基础组件，或与其它装饰者之间的组合关系
> * 类的行为如果依赖继承，那么行为是在编译时静态决定的。但是如果利用组合，把装饰者混合使用，就可以在运行时获得新的行为。
> * 使用装饰者模式，只有在针对抽象组件类型编程时，才不会因为被装饰后的对象影响。
> * 装饰模式可以为类注入弹性，但是如果装饰者的嵌套层次太深，很容易让使用者感觉的疑惑。


##工厂

###简单工厂
```简单工厂模式是属于创建型模式，又叫做静态工厂方法。它其实也不能算是一种设计模式😄.```

> * 于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则.添加新的类，则就需要改变工厂类了。
> * 产品类不断增多时候,很难避免模块功能的蔓延，对系统的维护和扩展非常不利。
> * 当需要创建的对象比较少，且独立的时候，不妨考虑使用简单工厂。

###工厂方法
```定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。```


####简单工厂 VS 工厂方法
```
子类看起来的确很像简单工厂。简单工厂把全部事情在一个地方处理完了😞,然而工厂方法却是创建一个框架，让子类决定怎么实现😆。
简单工厂可以把对象的创建封装起来，但是不具备工厂方法的弹性。因为它不能变更正在创建的产品。
```


###抽象工厂
```提供一个接口，用于创建相关或者依赖对象的家族，而不需要指定具体的类。```
####工厂方法 VS 抽象工厂
> * 工厂方法通过继承类来创建对象，抽象工厂通过对象组合来创建对象
> * 抽象方法用于把一系列相关的产品集合起来，但是当需要增加产品的时候，就需要改变接口。


###工厂模式要点
> * 所有工厂都是用来封装对象的创建。
> * 简单工厂虽然不是真正的设计模式，但是也是一种将程序从具体类解耦的好方法。
> * 所有工厂都是通过减少程序和具体类之间的耦合。
> * 工厂方法使用继承，抽象工厂使用组合。

